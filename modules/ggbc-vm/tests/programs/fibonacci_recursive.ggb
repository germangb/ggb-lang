fn fibonacci(n:u8):u8 {
    // values overflow an u8 at this point
    if (> n 13) {
        !! // panic
    }

    // memoization cache array
    // holds more items than this function can handle
    static CACHE:[u8 256]

    // handle base case
    if (| (==n 0) (==n 1)) {
        return 1
    }

    if (== ([n]CACHE) 0) {
        let n1:u8 = (fibonacci (-n 1))
        let n2:u8 = (fibonacci (-n 2))
        (= ([n]CACHE) (+n1 n2))
    }

    return ([n]CACHE)
}

static RESULT:[u8 2]
let t0:u8 = (fib 13)
let t1:u8 = (fib 4)
(= [0]RESULT t0)
(= [1]RESULT t1)
