






static@0x8000 VRAM:[u8 0x1000]
const ROM0:[i8 16] = 0;
const ROM1:[i8 16] = 0;
let bar0:u8 = 0
let bar1:&u8 = 0x42
let bar2:&[[u8 2] 2] = 0
let bar3:[u8 4] = [0 1 2 3]
let bar4:[&[u8 42] 6] = [0xff00 0xFF01 0xff02
                         0xff03 0xff04 0xff05]
fn do_something(byte:u8 array:[u8 3] ptr:&[[[u8 42] 42] 42]):u8 { return 0x25 }
fn do_nothing { }
let bar5:[u8 0] = (do_nothing)
let bar6:u8 = (do_something 9 [0xa 0xb 0xc] 0xdef0)
let bar7:u8 = 42
let bar8:u8 = 0x42
let bar9:&u8 = @bar0
let bar10:&[u8 4] = @bar3
let bar11:&[&[u8 42] 6] = @bar4
let bar12:&[u8 0x1000] = @VRAM
let bar13:&[i8 16] = @ROM0
let bar14:&[i8 16] = @ROM1







(= *foo [[bar 0] [0 bar]])

(edit @pos0 0 1) // edit(@pos0 0 1)

const ROM2:[u8 (+16 16)] = []
static BAZ:[u8 2]
static QUX:i8

// array of pointers
static FOO:[&[u8 16] 16]
// array of bytes
static BAR:[u8 16]

static@0x8000 VRAM2:struct {
    tile_data:union {
        x8000:struct {                    data:[u8 0x1000] }
        x8800:struct { padding:[u8 0x800] data:[u8 0x1000] }
    }
    tile_maps:struct {
        x9800:struct { tile:[u8 0x400] }
        x9c00:struct { tile:[i8 0x400] }
    }
}

//let foo:u8 = (+ (+ 1 (+ (+ 5 7) 4)) (+ 2 3))
//let bar:[u8 4] = [1 2 3 4]
//let baz:[u8 0] = []

//(= foo 42)

{
    if (& foo ~foo) {
        !!
    }
}

// ::add
//  ::0
//      ::a
//      ::b
//      ::c
//      ::d
//      ::tmp
fn add(a:u8
       b:u8
       c:u8
       d:u8):u8 {
    let tmp:u8 = (+a b)
    return (+ a (+ b (+ c d)))
}

// ::mul
//  ::0
//      ::a
//      ::b
//      ::tmp
//  ::1
//      ::_i
fn mul(a:u8 b:u8):u8 {
    (&= a 0xf)
    (&= b 0xf)
    let tmp:u8 = 0
    for _i:u8 in 0..b {
        (+= tmp a)
    }
    return tmp
}